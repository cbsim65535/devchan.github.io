--
layout: post
title: "코드 컨벤션의 역할 변화와 Design-First로 넘어가는 개발 문화"
date: 2025-04-23
categories: architecture devculture collaboration
--

## 1. 코드 컨벤션, 아직도 중요한가?

들여쓰기, 괄호 위치, 변수 이름.  
당신은 아직도 이런 걸 리뷰하고 있나요?

오랫동안 우리는 **코드 컨벤션**을 협업의 질서라고 믿어왔습니다.  
스타일을 통일하고, 팀 내의 일관성을 유지하는 건 당연한 미덕이었죠.

하지만 지금, 나는 질문하게 됩니다.  
**“정말 이게 우리가 합의해야 할 중요한 내용인가?”**

자동 포매터가 모든 스타일을 자동화해주고, AI는 명세도 없이 코드를 생성합니다.  
협업은 코드가 아닌 API 명세, 다이어그램, Notion 문서에서 일어나고 있습니다.

그리고 나는 이 흐름 속에서 **코드 컨벤션을 논의하는 시대는 서서히 저물고 있다고 느꼈습니다.**

그렇다면 우리는 무엇을 중심으로 협업해야 할까요?

이 글은 그 흐름을 따라갑니다.

- 코드 컨벤션은 어떻게 시작되었고, 왜 영향력을 잃어가는가  
- API 명세가 어떻게 협업의 중심이 되었는가  
- 단순한 명세를 넘어, 왜 구조와 의도가 공유되어야 하는가  
- 그리고 우리는 어떤 협업 문화를 만들어야 하는가

지금은 철학을 말해야 할 시간입니다.  
**우리는 “코드를 어떻게 썼는가”가 아니라, “왜 그렇게 만들었는가”를 말할 수 있어야 합니다.**

---

## 2. 코드 컨벤션, API-First, Design-First — 개념과 등장 배경

이 글에서 다루는 세 가지 개념은 모두  
**협업 구조의 변화**에 따라 등장한 실천 전략이다.  
각 용어는 단순한 트렌드가 아니라,  
**개발 환경의 복잡성 증가에 따른 생존 방식**이었다.

---

### ✅ 코드 컨벤션 (Code Convention)

- **등장 배경**: 협업 규모가 커지고, 코드 가독성이 문제가 되면서 필요성이 대두됨  
- **역할**: 스타일 통일, 리뷰 기준 제공, 유지보수 일관성 확보  
- **전환 계기**: 자동 포매터의 보편화, AI 코드 생성, 스타일 논의의 소멸

→ **현재는 도구가 처리하는 설정값 수준으로 역할 축소 중**

---

### ✅ API-First

- **등장 배경**: 팀 간 병렬 개발 시 API 계약이 없을 때 발생하는 충돌  
- **역할**: 명세 기반 계약, 자동화된 협업, 병렬 개발의 기반  
- **확산 요인**: Swagger(OpenAPI), Postman, Contract Testing 도구의 발전  
- **한계**: “무엇을 만들 것인가”만 정의, “왜 그렇게 만들었는가”는 설명 못함

---

### ✅ Design-First

- **등장 배경**: 도메인 복잡성 증가, API 명세만으로는 설계 판단 공유가 어려움  
- **역할**: 설계 구조, 책임 분리, 의사결정 근거를 코드 이전에 정의  
- **실천 수단**: ADR(Architecture Decision Record), 도메인 모델링, 설계 시각화  
- **표현 확산**: 2016년경 Stoplight·SwaggerHub 등에서 “Design-First” 명시화  
- **현재**: ‘설계 중심 협업 문화’로 실천 중심 용어로 분화됨 (RFC, 설계 리뷰 등)

---

### 🧠 핵심 요약

| 구분 | 핵심 질문 | 협업 중심 | 전환 이유 |
|------|-----------|------------|------------|
| 코드 컨벤션 | **어떻게 썼는가?** | 스타일 | 자동화로 대체됨 |
| API-First | **무엇을 만들 것인가?** | 인터페이스 | 병렬 개발 수요 |
| Design-First | **왜 그렇게 만들었는가?** | 구조와 의도 | 복잡성에 대한 대응 |

---

> 이 흐름은 **협업의 단위가 코드 → 인터페이스 → 설계 판단**으로 이동하는 진화를 보여준다.

---

## 2. 용어 정의 — 우리가 말하는 것들의 명확화

- **코드 컨벤션 (Code Convention)**  
  코드 스타일(들여쓰기, 네이밍, 공백 등)의 일관성을 유지하여  
  협업과 유지보수 효율을 높이기 위한 합의된 규범.

- **API-First**  
  API 명세를 코드보다 먼저 작성하고, 이를 기준으로 클라이언트·서버 개발을 병렬화하는 방식.  
  "API 계약이 소스 오브 트루스"라는 철학을 따름.

- **Design-First**  
  인터페이스 명세를 넘어서, 시스템 구조, 도메인 모델, 의사결정의 맥락을  
  설계 단계에서 기록하고 공유하는 전략. 복잡한 협업 구조에 대한 해석 도구.

--

## 3. 등장과 발전의 맥락 — 왜 이들이 등장했고 어떻게 진화했는가

| 구분         | 등장 원인             | 핵심 목적        | 확산 배경                     |
| ------------ | --------------------- | ---------------- | ----------------------------- |
| 코드 컨벤션  | 협업 가독성 문제      | 스타일 일관화    | 팀 확장, 리뷰 문화 정착       |
| API-First    | 계약 부재로 인한 충돌 | 명세 기반 협업   | OpenAPI, Swagger 생태계       |
| Design-First | 설계 맥락 공유 부재   | 구조와 의도 공유 | 도메인 복잡성, 설계 책임 분화 |

--

## 3. 코드 컨벤션은 어떻게 변하고 있는가

코드 컨벤션은 한때 팀 문화의 상징이었다.  
어떻게 쓰느냐를 정하고, 서로의 코드를 이해할 수 있도록 만드는 최소한의 규칙이었다.

하지만 지금은 그 위치가 점점 변하고 있다.

- **자동 포매터**가 대부분의 스타일 논쟁을 사전에 제거한다  
- **AI가 생성한 코드**는 일관된 스타일을 보장하지 않는다  
- **스타트업 환경**에서는 빠른 실험과 폐기 반복 속에, 컨벤션은 과잉이 될 수 있다  
- **협업의 중심축**은 코드 스타일이 아니라 구조, 인터페이스, 설계 의도로 이동하고 있다

나는 이 흐름 속에서  
**코드 컨벤션이 더 이상 협업의 중심은 아니라는 사실을 체감하고 있다.**

컨벤션은 완전히 사라진 것이 아니라,  
그저 **자동화된 설정값**으로 옮겨간 것이다.

> 여전히 존재하지만,  
> 더 이상 논의되지 않는 문화 — 그것이 오늘날의 코드 컨벤션이다.

---

## 4. API-First: 소통의 기술적 표준화

코드의 스타일을 맞추는 시대에서,  
이제 협업은 **무엇을 만들고, 어떻게 연결할 것인가**를 명확히 하는 일이 되었다.  
이 흐름에서 등장한 전략이 바로 **API-First**이다.

API-First는 기능을 구현하기 전에  
**명세(Specification)를 먼저 작성하고, 그것을 기준으로 협업을 시작하는 방식**이다.  
API는 단순한 인터페이스가 아니라,  
**계약(Contract)**이자 **개발의 기준선**이 된다.

---

### ✅ API-First가 만들어낸 변화

- **API 명세가 소스 오브 트루스가 된다**  
  → OpenAPI, GraphQL, gRPC 등으로 인터페이스를 표준화하고 공유

- **서버·클라이언트가 병렬 개발이 가능해진다**  
  → 명세 기반의 Mock 서버, 스텁 코드, 자동 문서화가 지원됨

- **협업이 스펙을 중심으로 전환된다**  
  → 코드가 아니라, 스펙이 논의의 출발점이 된다

---

그러나 API-First에는 한계가 있다.  
**“무엇을 만들 것인가”는 정의할 수 있어도,  
“왜 그렇게 만들었는가”는 설명할 수 없다.**

- 도메인 모델이 왜 그렇게 나뉘었는지  
- 책임 경계는 어떤 판단으로 설계되었는지  
- API 변화가 어떤 맥락에서 발생했는지

이러한 **설계의 맥락과 판단의 흐름**은 API 명세만으로는 공유될 수 없다.

> 그래서 우리는 API 명세를 넘어서  
> **설계 중심의 협업 문화**, 즉 구조적 의사소통이 필요한 시대에 도달해 있다.

--

## 5. 설계 중심 개발: 복잡성에 대응하는 전략적 흐름

도메인이 복잡해질수록,  
우리는 단순한 인터페이스 명세만으로는 협업을 감당할 수 없다는 걸 알게 된다.

- 팀이 늘어나고  
- 서비스가 분리되고  
- 도메인이 얽히면서  
협업의 대상은 코드가 아니라 **구조와 판단**이 되었다.

이 지점에서 필요한 것이 바로  
**설계 중심 개발**, 흔히 Design-First라 불리는 접근이다.

---

### ✅ 설계 중심 개발이 지향하는 것

- **도메인 모델링**  
  → 기능을 분리하고 책임을 명확히 하기 위한 개념적 구조 정의

- **설계 흐름의 시각화**  
  → 다이어그램(시퀀스, 상태 전이, 컴포넌트) 등을 통해 구조를 공유

- **ADR (Architecture Decision Record)**  
  → 어떤 결정을 왜 내렸는지를 기록으로 남기는 방식

- **RFC 기반 설계 협업**  
  → 팀 간 설계 제안과 피드백의 구조화된 과정

### 🧠 핵심 통찰

> 설계 중심 개발은 단순히 API를 먼저 만드는 방식이 아니다.  
> 그것은 **복잡한 구조를 판단 가능한 방식으로 설명하려는 문화**이다.

오늘날 우리는,  
**무엇을 만드는가**가 아니라  
**왜 그렇게 만들었는가**를 설명할 수 있어야 한다.

그 설명이 없는 시스템은  
변화에 취약하고, 협업에 무의미하다.

---

## 6. 앞으로의 문화는 어떻게 달라져야 하는가?

이제 우리는 코드 스타일이 아니라,  
**판단 가능한 구조와 의사결정의 흐름**을 공유해야 하는 시대에 있다.

협업의 방식은 변하고 있고,  
그에 맞춰 **개발 문화도 재정립**되어야 한다.

---

### ✅ 앞으로의 협업 문화는 이렇게 달라져야 한다

- **코드 스타일은 도구에 맡긴다**  
  → Prettier, Black, gofmt 등으로 스타일 논쟁 제거

- **인터페이스는 명세로 계약한다**  
  → OpenAPI, GraphQL, Protobuf 등으로 API 정의를 명확히

- **설계 판단은 기록한다**  
  → ADR, RFC 등으로 설계의 맥락을 남기고 공유

- **책임과 구조는 설계 단계에서 합의한다**  
  → 도메인 모델링, 경계 설계, 명세 기반 시각화를 통해 구조적 협업 수행

---

우리는 더 이상  
- 변수명을 논의하고  
- 포맷팅을 리뷰하고  
- 기능의 의도를 추정하는  
시대를 살고 있지 않다.

> 설계는 협업의 출발점이다.  
> 그리고 그 설계를 공유하는 문화가  
> **팀의 유지보수성과 확장성, 나아가 생존 가능성을 결정짓는다.**

---

## 7. Conclusion — 우리는 무엇을 합의해야 하는가?

코드 컨벤션은 오랫동안 협업의 질서를 만드는 도구였다.  
그리고 지금도 여전히 존재하는 규범이다.

하지만 나는 점점 더 많은 팀들이  
**코드를 어떻게 썼는가**보다는  
**왜 그렇게 만들었는가**를 중심으로 협업하려는 흐름에 닿고 있음을 느낀다.

자동화된 포매터, AI 보조 개발, 인터페이스 중심 협업은  
코드 자체보다 구조, 책임, 맥락을 먼저 논의하게 만들었다.

---

우리는 이제  
- 코드 스타일이 아니라 **구조를 합의**하고  
- 인터페이스 명세가 아니라 **설계 판단을 공유**하며  
- 코드 리뷰가 아니라 **설계 기록을 통해 협업**해야 한다.

---

Design-First의 필요성을 이야기해왔다.  
아직은 Design-First란 주제가 어색한 시간이라고 느낀다

그래서 이 글을 다시 쓴다.  

> 컨벤션은 도구가 대신하게 되었고,  
> 우리가 진짜로 합의해야 할 것은 **코드가 아니라 구조, 그리고 판단 가능한 설계의 흐름**이다.

--

## Appendix: Code Convention, API-First, Design-First의 연혁 정리

### Code Convention

| 연도      | 사건/흐름                                                                      |
| --------- | ------------------------------------------------------------------------------ |
| 1968      | Edsger Dijkstra, 구조적 프로그래밍 주장 (“Go To Statement Considered Harmful”) |
| 1974      | Kernighan & Plauger, 『The Elements of Programming Style』 출간                |
| 1978      | K&R C 스타일 등장, 이후 각 언어별 컨벤션 형성                                  |
| 1990s\*\* | Java, C++, Python 등 언어 중심 스타일 가이드 확산                              |
| 2010s     | ESLint, PEP8, gofmt 등 린터/포매터의 자동화 도입                               |
| 2020s~    | Prettier, Black, clang-format 등 도구 중심 자동 포맷 정착                      |

→ 컨벤션은 점차 사람이 아닌 도구가 지키는 영역으로 이동

--

### API-First

| 연도      | 사건/흐름                                                                    |
| --------- | ---------------------------------------------------------------------------- |
| 2000s 초  | SOAP/XML 기반 웹 API 등장 (Salesforce, eBay, Amazon 등)                      |
| 2011      | Swagger (후에 OpenAPI) 공개: 명세 기반 API 개발 시작                         |
| 2014~2017 | Google Cloud API Design Guide, Microsoft REST Guidelines 등 대기업 기준 공개 |
| 2016      | Swagger → OpenAPI로 재정립, Linux Foundation 주관                            |
| 2018~     | Stoplight, Postman, Pact 등 API 설계/문서화 도구 확산                        |

→ API 명세가 협업의 계약이 되고, 개발 병렬화의 기반이 됨

--

### Design-First

| 연도          | 사건/흐름                                                                    |
| ------------- | ---------------------------------------------------------------------------- |
| 2010년대 초반 | Domain-Driven Design(DDD)와 함께 시스템 구조 설계 중심 문화 논의             |
| 2015          | ADR(Architecture Decision Record) 문화 확산 (Michael Nygard 외)              |
| 2016~2017     | Stoplight, SwaggerHub 등 API 설계 도구에서 “Design-First”라는 용어 사용 시작 |
|               | 명세 중심(API-First) 개발을 넘는 개념으로 '설계 우선 접근'을 명시화          |
| 2016~2020     | API-First에 포함된 흐름으로 “의도와 설계의 기록” 요구 부상                   |
| 2020s         | RFC 기반 협업, 도메인 모델링, 설계 시각화 등 실천형 도구와 함께 정착         |

→ “API 명세 이전의 구조적 합의”를 문화로 정착시키는 흐름

--

> 이 세 가지 개념은 모두 **개발 환경의 복잡성 증가**와  
> **협업의 단위 변화**에 대응하기 위해 발전해왔다.
