--
layout: post
title: "코드 컨벤션의 역할 변화와 Design-First로 넘어가는 개발 문화"
date: 2025-04-23
categories: architecture devculture collaboration
--

## 1. 질문은 바뀌었다: “왜 이렇게 만들었는가?”

코드 컨벤션은 오랫동안 개발자들 사이에서 협업의 질서를 만드는 도구로 사용되어 왔다.  
그러나 최근 나는, 점점 더 많은 팀에서 **코드 컨벤션이 협업의 중심이 아닌 것으로 간주되는 현상**을 관찰하고 있다.  
자동화 도구, AI 보조 개발 환경, API 명세 기반 협업의 확산은  
단순한 스타일의 일치를 넘어서 **설계와 구조의 공유**를 중심에 놓는 흐름으로 옮겨가고 있다.

그러나 최근 몇 년 사이, 코드 컨벤션의 존재 이유에 대해 질문이 생기고 있다.  
자동 포매터가 스타일을 통일해주고, AI가 코드를 생성하며, 협업은 점점 코드 밖에서 이루어진다.  
더 이상 "어떻게 썼는가"가 중요한 게 아니라, "왜 그렇게 만들었는가"를 설명할 수 있어야 하는 시대가 되었다.

이 글은 다음의 흐름을 따라간다:

- 코드 컨벤션이 어떻게 등장하고 작동했는가
- 왜 그것이 중심이 아니게 되었는가
- API-First와 Design-First는 어떤 전환의 흐름을 말해주는가
- 그리고 지금 우리는 어떤 문화를 준비해야 하는가

--

## 2. 용어 정의 — 우리가 말하는 것들의 명확화

- **코드 컨벤션 (Code Convention)**  
  코드 스타일(들여쓰기, 네이밍, 공백 등)의 일관성을 유지하여  
  협업과 유지보수 효율을 높이기 위한 합의된 규범.

- **API-First**  
  API 명세를 코드보다 먼저 작성하고, 이를 기준으로 클라이언트·서버 개발을 병렬화하는 방식.  
  "API 계약이 소스 오브 트루스"라는 철학을 따름.

- **Design-First**  
  인터페이스 명세를 넘어서, 시스템 구조, 도메인 모델, 의사결정의 맥락을  
  설계 단계에서 기록하고 공유하는 전략. 복잡한 협업 구조에 대한 해석 도구.

--

## 3. 등장과 발전의 맥락 — 왜 이들이 등장했고 어떻게 진화했는가

| 구분         | 등장 원인             | 핵심 목적        | 확산 배경                     |
| ------------ | --------------------- | ---------------- | ----------------------------- |
| 코드 컨벤션  | 협업 가독성 문제      | 스타일 일관화    | 팀 확장, 리뷰 문화 정착       |
| API-First    | 계약 부재로 인한 충돌 | 명세 기반 협업   | OpenAPI, Swagger 생태계       |
| Design-First | 설계 맥락 공유 부재   | 구조와 의도 공유 | 도메인 복잡성, 설계 책임 분화 |

--

## 4. 코드 컨벤션은 어떻게 변하고 있는가

- **자동 포매터**: Prettier, Black 등 도구가 스타일 논의를 제거
- **코드 외 협업 증가**: Slack, Notion, API 문서 중심 소통
- **AI 코드 생성**: Copilot, GPT가 혼합 스타일로 코드 생성 → 리뷰의 무력화
- **빠른 폐기 코드**: 실험·MVP 중심 개발에서 컨벤션은 과잉 비용
- **협업 도구로서의 기능 상실**: 컨벤션은 설정값 수준으로 전락

코드 컨벤션은 더 이상 팀 협업에서 **중심 역할을 하지 않는 경우가 많아지고 있다.**  
이제 그것은 도구가 자동으로 해결해주는 영역으로 밀려났으며,
협업에서 더 중요한 것은 **구조, 설계 의도, 그리고 인터페이스 정의의 명확성**이 되었다.

--

## 5. API-First: 소통의 기술적 표준화

복잡한 시스템 환경에서 팀 간 협업은 "코드를 먼저 짠 다음 공유한다"는 방식으로는 한계에 부딪혔다.  
서버 팀과 클라이언트 팀, 프론트와 백엔드, 여러 도메인 팀들이 각기 다른 시간과 속도로 움직이게 되면서,
**명확한 인터페이스 정의 없이는 개발 병렬화도, 테스트도 불가능해졌다.**

이 문제를 해결하기 위해 등장한 것이 **API-First**이다.  
API 명세를 설계 단계에서 먼저 정의하고, 그 명세를 기준으로 모든 개발자가 작업하는 방식이다.

이 접근은 다음의 변화를 만들어냈다:

- **인터페이스가 계약이 되었다**  
  → 명세(OpenAPI, GraphQL, gRPC 등)가 곧 개발의 기준이 되었고,
  그 기준은 Swagger UI, Postman, Stoplight 등 다양한 도구로 시각화되고 문서화된다.

- **팀 간 병렬 작업이 가능해졌다**  
  → 명세 기반으로 서버/클라이언트가 동시 개발. API Mocking, Contract Testing을 통한 리스크 감소.

- **자동화 생태계가 확산되었다**  
  → 명세 기반 코드 생성, 테스트 자동화, 문서 자동 게시까지 통합 가능

그러나 API-First는 여기까지다.  
이 방식은 **“무엇을 만들 것인가”**에 대한 명확한 약속은 제공하지만,
**“왜 그렇게 만들었는가”**, **“그 구조는 어떤 판단에 의한 결과인가”**를 설명하진 않는다.

복잡성이 높아질수록, API 계약만으로는 부족해진다.

--

## 6. Design-First: 복잡성에 대응하는 설계 전략

API 명세는 기능의 입출력을 설명하지만,
그 API가 왜 존재하는지, 그 기능이 어떤 맥락 속에서 탄생했는지를 설명하진 않는다.

시스템이 커지고 도메인이 분화되며,
**"왜 그렇게 만들었는가"를 아는 것이 협업의 핵심**이 되었다.  
단순한 계약 이상의 구조적 의도와 판단을 공유해야 할 필요성이 커진 것이다.

이런 배경 속에서 등장한 접근이 흔히 **Design-First**라 불리는 방식이다.  
다만 최근 실무에서는 이 용어보다 '설계 기반 협업', '의사결정 기록 문화'와 같이 더 구체적인 실천 단위로 나뉘어 언급된다.

우리는 이를 넓은 의미의 Design-First라고 부른다.  
단지 API 명세를 먼저 정의하는 것이 아니라,
복잡한 도메인과 변화의 흐름 속에서  
**설계의 판단, 책임의 분리, 의사결정의 맥락을 명시적으로 공유**하려는 전략이다.  
최근에는 이 개념이 ADR(Architecture Decision Record), 도메인 중심 설계,
설계 기반 RFC 등 실천 위주의 언어로 분산되어 사용되고 있다.

### Design-First가 요구하는 것들

- **도메인 모델링**  
  복잡한 기능을 책임 단위로 나누고, 팀 간 경계를 설계한다

- **설계 흐름의 시각화**  
  시퀀스 다이어그램, 상태 전이, 흐름도 등으로 동작 맥락을 공유한다

- **ADR(Architecture Decision Record)**  
  구조적 판단이 이루어진 이유, 고려된 대안, 선택의 근거를 문서로 남긴다

- **RFC (Request for Comments)**  
  팀 간의 구조적 논의를 기록하고, 설계안을 공유 가능한 포맷으로 만든다

### 핵심 통찰

> 이 흐름은 **도메인의 복잡성에서 기인**했고,
> 그로 인해 **소통의 표준을 만들려는 설계 전략**이다.

복잡한 문제일수록, 설계의 출발점을 기록하고 설명해야 한다.  
그것이 협업의 기반이 되며, 조직의 지식 자산으로 남는다.

Design-First는 그 흐름의 중심에서  
**"코드 이전의 판단 가능한 구조를 설계하고 합의하는 문화"**를 만든다.

--

## 7. 앞으로의 문화는 어떻게 달라져야 하는가?

지금까지의 흐름은 단순한 개발 방식의 변화가 아니다.  
이는 **협업의 단위가 바뀌고**, **소통의 기준이 달라졌으며**,
**기록의 방식이 구조 중심으로 이동했다는 신호**다.

우리는 더 이상 다음과 같은 방식으로 일할 수 없다:

- 코드를 예쁘게 작성했는지에만 집착하고
- PR에서 포매팅과 변수명을 지적하며
- 스펙 없이 기능을 구현하고, 뒤늦게 문서를 쓰고
- 설계 판단은 사람 머릿속에만 존재하는 상태로 남기는 것

이제 바뀌어야 한다. 우리가 맞이해야 할 새로운 협업 문화는 다음과 같다:

- **코드 스타일은 도구에 맡기자**  
  → Prettier, Black, gofmt 등으로 스타일 논쟁 제거

- **API 명세는 팀 간 계약이다**  
  → OpenAPI, GraphQL SDL 등으로 협업 기반 구축

- **설계의 의도는 기록하고 공유해야 한다**  
  → ADR과 RFC를 통해 설계 판단의 흐름을 남긴다

- **의사결정은 구조의 일부다**  
  → 설계는 코드 이전에 설명되어야 한다

### 요약하면

> **스타일을 맞추는 문화는 종료되었다.  
> 이제는 판단 가능한 구조를 설계하고 공유하는 문화로 넘어가야 한다.**

Design-First는 그 새로운 문화의 출발점이다.

--

## 8. 우리는 무엇을 합의해야 하는가?

코드 컨벤션은 오랫동안 협업을 위한 최소한의 약속이었다.  
그리고 지금도 여전히 유용한 도구이다.  
다만 내가 관찰한 바에 따르면, 많은 팀이 이제 코드 스타일보다는  
**설계와 구조의 일관성**을 더 중시하는 방향으로 협업 문화를 조정하고 있다.

복잡한 도메인, 분화된 팀, 다양한 언어와 플랫폼이 공존하는 시대에  
중요한 것은 **코드를 어떻게 썼는가**가 아니라,
**왜 그렇게 만들었는가를 함께 이해하는 구조**다.

API-First는 이러한 변화의 첫 번째 단계였다.  
명세를 통해 협업의 기준을 세우고, 계약을 기술적으로 자동화한 방식이었다.  
그러나 그것만으로는 설명할 수 없는 것이 있다.

바로, 설계의 의도다.  
구조의 맥락이고, 판단의 흔적이며,
앞으로의 변화에 대응할 수 있는 설계 기반이다.

> **이제 우리가 합의해야 하는 것은 코드가 아니다.  
> 구조다. 설계다. 판단 가능한 흐름이다.**

그리고 그것이 바로 오늘날 우리가 실천하고자 하는 **설계 중심 협업 문화**의 본질이다.

--

--

## Appendix: Code Convention, API-First, Design-First의 연혁 정리

### Code Convention

| 연도      | 사건/흐름                                                                      |
| --------- | ------------------------------------------------------------------------------ |
| 1968      | Edsger Dijkstra, 구조적 프로그래밍 주장 (“Go To Statement Considered Harmful”) |
| 1974      | Kernighan & Plauger, 『The Elements of Programming Style』 출간                |
| 1978      | K&R C 스타일 등장, 이후 각 언어별 컨벤션 형성                                  |
| 1990s\*\* | Java, C++, Python 등 언어 중심 스타일 가이드 확산                              |
| 2010s     | ESLint, PEP8, gofmt 등 린터/포매터의 자동화 도입                               |
| 2020s~    | Prettier, Black, clang-format 등 도구 중심 자동 포맷 정착                      |

→ 컨벤션은 점차 사람이 아닌 도구가 지키는 영역으로 이동

--

### API-First

| 연도      | 사건/흐름                                                                    |
| --------- | ---------------------------------------------------------------------------- |
| 2000s 초  | SOAP/XML 기반 웹 API 등장 (Salesforce, eBay, Amazon 등)                      |
| 2011      | Swagger (후에 OpenAPI) 공개: 명세 기반 API 개발 시작                         |
| 2014~2017 | Google Cloud API Design Guide, Microsoft REST Guidelines 등 대기업 기준 공개 |
| 2016      | Swagger → OpenAPI로 재정립, Linux Foundation 주관                            |
| 2018~     | Stoplight, Postman, Pact 등 API 설계/문서화 도구 확산                        |

→ API 명세가 협업의 계약이 되고, 개발 병렬화의 기반이 됨

--

### Design-First

| 연도          | 사건/흐름                                                                    |
| ------------- | ---------------------------------------------------------------------------- |
| 2010년대 초반 | Domain-Driven Design(DDD)와 함께 시스템 구조 설계 중심 문화 논의             |
| 2015          | ADR(Architecture Decision Record) 문화 확산 (Michael Nygard 외)              |
| 2016~2017     | Stoplight, SwaggerHub 등 API 설계 도구에서 “Design-First”라는 용어 사용 시작 |
|               | 명세 중심(API-First) 개발을 넘는 개념으로 '설계 우선 접근'을 명시화          |
| 2016~2020     | API-First에 포함된 흐름으로 “의도와 설계의 기록” 요구 부상                   |
| 2020s         | RFC 기반 협업, 도메인 모델링, 설계 시각화 등 실천형 도구와 함께 정착         |

→ “API 명세 이전의 구조적 합의”를 문화로 정착시키는 흐름

--

> 이 세 가지 개념은 모두 **개발 환경의 복잡성 증가**와  
> **협업의 단위 변화**에 대응하기 위해 발전해왔다.
