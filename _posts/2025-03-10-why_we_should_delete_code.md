---
layout: post
title: "우리는 왜 코드를 삭제해야 하는가?"
date: 2025-03-10
tags: [설계철학, 조직문화]
---

# I. 철학을 이해한다

### 1. 개발 문화는 코드에서 시작되지 않는다

개발 문화는 도구나 프로세스로 만들어지지 않는다. 조직의 사고방식, 리더십의 기준, 그리고 팀이 공유하는 기술 철학에서 시작된다. 이 글은 우리가 어떻게 설계하고, 어떤 철학으로 개발 문화를 만들어가고 있는지에 대한 이야기다. 그리고 그 중심에는 "코드는 언제든 삭제될 수 있어야 한다"는 강력한 철학이 있다.

### 2. 설계는 기술의 문제가 아니라, 기준의 문제다

설계는 기술 스택이나 디자인 패턴 이전에, 우리가 어떤 기준 아래에서 시스템을 만들고 있는지의 문제다. 기준 없는 설계는 방향을 잃기 쉽고, 기술적인 복잡성만 늘어난다.

우리가 말하는 기준이란, 무엇을 중심으로 시스템을 나누고, 기능을 결정하며, 어떤 구조가 우리에게 유연성을 줄 수 있는지를 판단하는 **의사결정의 중심축**이다.

기준이 명확한 팀은 어떤 기능을 만들지보다, **어떤 기능을 언제 걷어낼 수 있을지를 함께 고민한다**. 기준이 모호한 팀은 무조건 만드는 데 집중하고, 결과적으로 유지 비용과 리스크만 늘어난다.

'사용자 상태 태그 기능'은 기획의 변화에 따라 계속 확장되었고, 설계 기준 없이 추가된 조건문과 플래그들이 전체 사용자 시스템을 불안정하게 만들었다. 이후 "태그는 언제든 폐기 가능해야 한다"는 기준을 세우고, 외부 JSON 스키마로 분리하여 실험 종료 시 제거 가능한 구조로 전환해야 한다. 

> "이건 나중에 지울 수 있는가?"
> 

### 3. 애자일은 도구가 아니라, 검증과 학습의 속도다

많은 팀이 애자일을 Jira, Sprint, Retrospective 같은 프로세스로 이해한다. 그러나 우리가 믿는 애자일의 본질은 **고객이 원하는 가치를 얼마나 빨리 검증하고, 그것으로부터 얼마나 빠르게 학습할 수 있는가**에 있다.

그 속도를 유지하려면 시스템은 항상 유연해야 하며, 그 유연함은 **삭제 가능한 구조**에서 온다. 즉, 실험하고 걷어낼 수 있는 설계를 해야만 진짜 애자일이 가능하다.

한 기능을 '실험 플래그' 형태로 릴리스한 후, 피드백이 부정적일 경우 코드와 설정 전체를 삭제했다. 실패는 축적이 아닌 학습으로 전환되었고, 팀은 빠르게 방향을 전환할 수 있었다.

---

# II. 구조를 만든다

### 4. 삭제 가능한 구조, 살아 있는 시스템

모든 코드는 언젠가 사라진다. 중요한 건 그것을 예상하고 만드는가의 여부다. 우리는 코드의 수명을 가정하며 설계하고, 유효기간이 짧은 코드는 격리하고, 오래가는 코드는 구조화한다.

삭제 가능한 구조는 의존성이 낮고, 책임이 분리되어 있으며, 위임 가능한 구조를 의미한다.

| 원칙 | 설명 |
| --- | --- |
| 느슨한 결합 | 기능 간 연결을 최소화하여 독립성 확보 |
| 책임 분리 | 한 모듈이 하나의 역할만 갖도록 설계 |
| 위임 가능 | 외부로의 교체나 폐기가 가능한 구조 |
| 실험 친화 | 쉽게 붙이고 쉽게 걷어낼 수 있는 구조 |

알림 시스템은 초기에는 간단한 유틸로 시작되었고, 반복적 사용으로 인해 독립된 모듈과 외부 연동 서비스로 승격되었다. 초기 구현은 깔끔하게 제거되었고, 시스템은 더 단순해졌다.

---

# III. 실행한다

### 5. 개발 문화로서의 '삭제'

삭제에는 책임이 따른다. 삭제는 단지 리팩터링이 아니라 **팀이 어떤 것을 더 이상 유지하지 않겠다는 합의**이자, **의도를 정리하고 책임을 종료하는 일**이다. 우리는 삭제 로그와 영향 범위를 함께 기록한다.

**삭제 문화의 실천 예시:**

- 코드 리뷰에서 "이건 나중에 지울 수 있나요?"를 묻는다
- `temporary-`, `experimental-` 네이밍으로 삭제 의도를 명시한다
- 삭제 LOC, 제거된 모듈 수, 폐기 기능을 KPI로 삼는다

과거 어떤 기능이 있았다. 
한시적 기능이었으나, 폐기 시기를 놓쳐 시스템 테스트에 부담을 주었다. 
제거 결정과 함께 회고가 공유를 통해 시스템은 개성 될 수 있었다. 
이후 실험 기능을 개발하면,
- 명확히 태깅한다
- 폐기 주기를 설정한다

또는 우리는 문제를 마주했을 때 이렇게 자문한다:

> "이건 내가 지금 대답할 수 있는 문제인가?"
> 

답이 없다면, 
여기도 태깅을 통해 삭제 가능함을 정의한다. 

- 언제까지 시간을 투입할 것인가. 

이것이야말로 **불확실성과 복잡성을 걷어내는 방식**, 즉 삭제 가능한 문화의 실천이다.

> "많이 만드는 것보다 잘 걷어내는 것이 실력이다."
> 
> 
> "삭제는 팀이 책임을 정리하는 일이다."
> 

---

# IV. 학습하고 전파한다

### 6. 정보 공유와 지식 베이스

**설계 시점에 묻는 질문들:**

- 이 기능은 언제 사라질 수 있는가?
- 다른 서비스에 영향을 주는가?
- 실패 시 어떻게 폐기할 수 있는가?

이 질문은 기능이 아닌 **설계 자체의 수명을 디자인**하는 과정이다.

**지식 공유 원칙:**

- 설계는 구두가 아닌 기록으로 설명한다
- 반복 질문은 지식 베이스에 정리한다
- 실험은 문서화하고, 삭제는 히스토리로 남긴다

우리는 Notion과 GitHub Discussions를 통해 실험의 배경과 과정을 기록하고, 삭제된 기능의 사유를 명시하여 재요구 시 의사결정 근거로 활용한다.

또한 매 분기 "잘 삭제한 사례"를 회고하고, 신입 팀원에게는 ‘작성 원칙’보다 **삭제 설계 원칙**을 먼저 교육한다. 
이는 단순한 기술 문법보다 더 중요한 우리 팀의 철학이다.

---

# V. 철학으로 되새긴다

### 7. 우리는 지우는 팀이다

우리는 언제나 코드를 덜어내기 위한 구조를 만든다. 
이는 기술 철학이자, 팀의 정체성이다.

> "살아남는 코드는, 삭제될 준비가 된 코드다"
> 

그리고 그 철학이 우리 팀의 설계를 결정짓고, 개발 문화를 만든다.

우리는 만드는 것보다, **덜어내는 용기**를 먼저 배운다.

---
